\chapter{Evaluarea unor tehnici de testare}

Pentru a dovedi relevanța suitei de aplicații construită anterior vom desfășura o serie de experimente folosind mai multe tehnici și tehnologii adecvate pentru testarea sistemelor \acrshort{iot}. 

% TODO: de palavragit un pic despre cercetarea empirica si de ce e buna
% TODO: de vorbit despre analiza cantitativa vs analiza calitativa
% TODO: de ales niste metrici de evaluare si motivat de ce
% TODO: de rezumat tehnicile si structura capitolului

% criterii evaluare:
% automat vs manual
% timp necesar pentru setup, complexitate setup
% tipul de defecte care pot fi detectate
% timp necesar pentru descoperirea defectelor
% eficienta (cat la suta din defectele existente au fost detectate)
% limitari si dezavantaje
% futher work

\section{Testarea funcțională}

% TODO: de vorbit la general despre testarea functionala, dar scurt
Am explicat în capitolul al doilea, secțiunea 2.1.2, ce este testarea funcțională și care sunt caracteristicile acesteia, așa că nu vom relua explicarea noțiunii. În secțiunea curentă vom vorbi despre o serie de tehnici de testare funcțională pe care le-am utilizat atât pentru a valida funcționarea corectă a suitei de aplicații, cât și pentru a oferi dovada reproductibilității defectelor existente.

Vom compara o abordare proprie inspirată de principiile metodologiei \acrfull{bdd}, metodologie despre care vom vorbi pe larg mai jos, și un \textit{framework} experimental realizat de \cite{Bures2021} pentru testarea de integrare și interoperabilitate a sistemelor \acrshort{iot}.

\subsection{Metodologia Behaviour-Driven Development}

% TODO: de folosit continutul din paper

\acrfull{bdd} este o metodologie de dezvoltare succesoare a \acrfull{tdd} care se preocupă de crearea de specificații clare și automatizabile pentru testarea sistemului țintă. Pentru a atinge acest scop, \acrshort{bdd} propune o terminologie standardizată pentru proiectarea cazurilor de test pentru a ușura formularea lor atunci când mai multe părți sunt implicate (\textit{stakeholders}), cum ar fi dezvoltatori, clienți sau personalul de vânzări. Vom prezenta pe scurt această metodologie bazându-ne pe studiul realizat de \cite{Solis2011} despre caracteristicile \acrshort{bdd}.

Conform studiului, această metodologie pune accent pe folosirea unui limbaj comun, standardizat și independent de domeniul de aplicare pentru descrierea scenariilor de test. Scenariile sunt apoi formulate ca text în limbaj natural, cât mai simplu posibil și orientate spre descrierea de comportamente (en. \textit{behaviour}). De exemplu, formatul cel mai des întâlnit pentru formularea scenariilor de test poate fi observat mai jos.

\begin{lstlisting}[caption={Structură comună a unui scenariu de test folosind BDD}]
Scenario X: Titlul scenariului
Given: Contextul în care va fi efectuat testul
When: Este observat un anume eveniment 
(ex. click-ul unui utilizator pe un buton anume)
Then: Rezultatul dorit
\end{lstlisting}

Această standardizare oferă posibilitatea transpunerii directe a scenariilor în teste automate pentru a putea valida funcționalitățile sistemului.

În articolul realizat de \cite{Cristea2022}, am abordat testarea funcțională a suitei de aplicații propuse folosind concepte inspirate din metodologia \acrshort{bdd}. Deoarece testarea unitară nu poate asigura funcționarea corectă a unui sistem atunci când mai multe componente sunt integrate împreună, testele funcționale au avut în vedere angrenarea mai multor aplicații din suită și verificarea fluxurilor de date care circulă între ele.

Pentru descrierea și automatizarea testelor am utilizat biblioteca Python Behave \footnote{Documentația și codul sursă pot fi găsite la adresa \url{https://behave.readthedocs.io/en/stable/}} care permite formularea scenariilor de test în limbaj natural și le asociază cu testele automate scrise în limbajul Python. Deși scenariile sunt descrise în limbaj natural, ele trebuie să respecte sintaxa impusă de standardul Gherkin \footnote{Mai multe informații și specificația completă a limbajului pot fi găsite la adresa \url{https://cucumber.io/docs/gherkin/}}, care asigură structurarea corectă a scenariilor de test. În cardul articolului am prezentat un exemplu de scenariu de test pe care îl vom reproduce mai jos în secvența cu numărul \ref{exemplu_bdd}. Acest scenariu este declanșat de regulile de automatizare din aplicația \textit{hub} și vizează setarea corespunzătoare e luminozității \textit{smart TV}-ului în funcție de datele colectate de senzorul de luminozitate al ferestrei. Testul va fi executat de \textit{framework}-ul Behave pentru toate valorile din tabelul de exemple.

\begin{lstlisting}[caption={Exemplu de scenariu de test BDD pentru aplicațiile din suită}, label={exemplu_bdd}]
(*\textbf{Feature:}*) TV auto-brightness
  (*\textbf{Scenario Outline:}*) TV brightness is set based on window luminosity level
    (*\textbf{Given}*) TV brightness is set to <X>, window luminosity to <Y> and base luminosity to <Z>
      (*\textbf{When}*) automation rules are triggered for TV
      (*\textbf{Then}*) TV brightness is set to max(10 - <Y>/10 + <Z>, <Z>) <= 10
     (*\textbf{Examples:}*)
      | X  | Y  | Z  |
      | 3  | 20 | 1  |
      | 4  | 70 | 0  |
      | 1  | 0  | 10 |
\end{lstlisting}

Pentru a adăuga un nou test în cadrul suitei de aplicații este nevoie de formularea lui în limbaj natural urmând constrângerile impuse de sintaxa Gherkin, iar apoi realizarea testului automat în limbajul Python. Un exemplu de astfel de test se poate regăsi în fragmentul cu numărul \ref{exemplu_python_behave}. Pasul \textit{given} creează contextul propice testării, anume setează senzorii la valorile dorite. Pasul \textit{when} declanșează regulile de automatizare din interiorul aplicației \textit{hub}, iar apoi pasul \textit{then} va verifica dacă valoarea luminozității colectată de la \textit{smart TV} corespunde cu rezultatul așteptat.

\begin{lstlisting}[caption={Exemplu test automat folosind biblioteca Behave}, label={exemplu_python_behave}, language={Python}]

from behave import *
import app

@given('TV brightness is set to {X}, window luminosity to {Y} and base luminosity to {Z}')
def step_impl(context, X, Y, Z):
    app.env.clients["smarttv"].set_brightness_level_post(int(X))
    
    app.env.clients["windwow"]\
        .settings_setting_name_setting_value_post(
            "luminosity", 
            int(Y),
        )

    app.env.settings["tv_base_brightness"] = int(Z)

@when('automation rules are triggered for TV')
def step_impl(context):
    app.env.run_simple()

@then('TV brightness is set to max(10 - {Y}/10 + {Z}, {Z}) <= 10')
def step_impl(context, Y, Z):
    Y = float(Y)
    Z = float(Z)
    assert app.env.data["smarttv"]["brightness"] == int(
        min(max(10 - Y/10 + Z, Z), 10)
    )
\end{lstlisting}

În urma aplicării acestei tehnici pe suita de aplicații am remarcat următoarele:
\begin{itemize}
    \item tehnica este manuală, deci limitată de experiența și timpul investit de cel care testează
    \item toate defectele existente în cardul suitei de aplicații pot fi detectate și reproduse, însă succesul detectării este dependent de factorul uman
    \item configurarea mediului de testare nu aduce complexitate suplimentară
\end{itemize}

Concluzionăm că acest tip de testare este potrivit atât testării individuale a aplicațiilor, cât și a acestora după integrare, însă această tehnică este mai degrabă aplicabilă în procesul de dezvoltare pentru testarea scenariilor pozitive, decât pentru descoperirea de defecte neobișnuite. Automatizarea generării de scenarii de test variate și reducerea dependenței față de factorul uman pot reprezenta două direcții interesante de cercetare ce ar ajuta la îmbunătățirea tehnicii.

\subsection{PatrIoT Framework}

% TODO: !!! trebuie sa fac eu experimentele cu PatrIoT si sa compar

\section{Testarea exploratorie folosind \emph{fuzzing}}

Testarea exploratorie își propune găsirea de stări marginale și excepționale ale unui sistem pentru a descoperi un număr cât mai mare de defecte. Acest tip de testare nu se concentrează în general pe scenariile pozitive, ci pe cele negative în care datele de intrare sunt de multe ori invalide parțial sau total.

În paragrafele următoare ne vom concentra pe o tehnică anume de testare exploratorie și anume \textit{fuzzing}-ul. Așa cum ne explică \cite{Manes2021}, \textit{fuzzing}-ul este o tehnică larg răspândită care presupune trimiterea de date de intrare malformate semantic sau sintactic spre un sistem software și monitorizarea reacției acestuia. 

În general, un algoritm de \textit{fuzzing} generează în mod aleator mutații pentru un set de date de intrare, apoi trimite datele de intrare la sistemul software țintă, iar în final evaluează starea rezultată și constată dacă au fost detectate defecte. Aceși pași se pot desfășura la infinit sau într-un interval de timp stabilit. În fragmentul \ref{fuzzing_algo} este reprezentată în pseudocod structura generală a algoritmului descris, așa cum ne-o înfățișează \cite{Manes2021}.

\begin{lstlisting}[label={fuzzing_algo}, caption={Structura generală a unui algoritm de fuzzing}]
(*\textbf{Input:}*) Configuration, (*$t_{limit}$*)
(*\textbf{Output:}*) Bugs

while (*$t_{elapsed}$*) < (*$t_{limit}$*):
    Configuration (*$\leftarrow$*) Schedule(Configuration, (*$t_{elapsed}$*), (*$t_{limit}$*))
    TestCase (*$\leftarrow$*) Generate(Configuration)
    NewBugs, ExecInfo (*$\leftarrow$*) Evaluate(Configuration, TestCase)
    Configuration (*$\leftarrow$*) Update(Configuration, ExecInfo)
    Bugs (*$\leftarrow$*) Bugs (*$\bigcup$*) NewBugs)
    
return Bugs
\end{lstlisting}

Deși structura generală este simplă, exista o gamă foarte largă de algoritmi de \textit{fuzzing}. Distingem trei categorii importante în funcție de cunoștințele semantice pe care acesta le deține despre interacțiunea cu sistemul:

\begin{itemize}
    \item \textit{black-box} - nu cunosc semantica datelor de intrare și nici codul sursă al aplicației
    \item \textit{grey-box} - dețin informații parțiale despre semantica datelor de intrare și au parte de un \textit{feedback} parțial din partea sistemului țintă
    \item \textit{white-box} - au cunoștințe depline despre semantica datelor și sistemul vizat
\end{itemize}

Un aspect foarte important al \textit{fuzzer}-elor este modul în care generează noi date de intrare. O abordare foarte populară este utilizarea de algoritmi genetici, astfel alegându-se mostrele cu cel mai mare succes raportat de o anume metrică. Pentru metricile de succes se utilizează în general acoperirea totală a codului (sursă sau cod mașină în funcție de caz).

Pentru detectarea defectelor este nevoie de un așa numit \textit{oracol}. Acesta este un mecanism care permite evaluarea stării sistemului țintă și poate raporta anumite tipuri de defecte. De exemplu, sistemul de operare va semnala un acces invalid de memorie, astfel un algoritm de \textit{fuzzing} poate lua la cunoștință că a descoperit un defect.

În paragrafele următoare vom analiza rezultatele a două \textit{fuzzer}-e ... TODO: de continuat aici

% TODO: de explicat ce inseamna testare exploratorie
% TODO: teorie fuzzing scurta, de gasit un paper de citat

\subsection{RESTler}

TODO: astept sa vad ce mai face rares cu fuzzing-ul

% TODO: de citat paper-ul de la restler si de folosit balariile din paper-ul de fuzzing de la SASHA

% TODO: de vazut ce mai zice rares si ce experimente mai face el

\subsection{FirmAFL}

% TODO: trebuie sa mai gasesc macar un fuzzer pe care sa-l rulez pe dataset ca sa am ce compara

\section{Analiză statică}

Tehnicile anterioare evaluate pot fi toate considerate dinamice în natură, deoarece presupun executarea codului aplicațiilor și observarea comportamentului în timpul execuției. O altă abordare care necesită mai puține resurse computaționale și nu este preocupată de executarea aplicațiilor este analiza statică. 

Analiza statică presupune în general mecanisme de recunoaștere și deducție de tipare problematice în codul sursă sau codul mașină al aplicațiilor. Așa cum ne spune analiza realizată de \cite{Gosain2015}, există mai multe tehnici de analizare statică:
\begin{itemize}
    \item recunoașterea constructelor sintactice problematice
    \item reprezentarea stărilor aplicației ca noduri într-un graf și analizarea fluxurilor de date
    \item interpretarea abstractă a programelor
    \item analiza bazată pe constrângeri și satisfacerea acestora
\end{itemize}

Această tehnică de analiză nu depinde de date de intrare concrete pentru aplicație și nici nu necesită analizarea întregului program pentru a putea oferi concluzii pertinente. Pe de altă parte însă, aceste caracteristici cauzează o rată mare a fals-pozitivelor și o imposibilitate a verificării corectitudinii funcționale. Astfel este o tehnică utilă pentru detectarea defectelor, însă nu suficient de comprehensivă pentru a fi singura tehnică utilizată.

În următoarele paragrafe vom prezenta evaluarea a trei unelte software pentru analizarea statică a programelor, două dintre ele fiind orientate pe analiza codului \textit{C/C++}, iar cea de a treia analizează aplicații care nu au codul sursă disponibil. În secțiunea următoare ne vom concentra pe un tip aparte de analiză statica, și anume analiza formală.

\subsection{cppcheck}

\textit{cppcheck} \footnote{Documentația și codul sursă al aplicației pot fi găsite la \url{https://cppcheck.sourceforge.io/}.} este un analizator static specializat pentru limbajele C și C++. Acesta urmărește detectarea de greșeli comune în programare și se concentrează în special pe acele greșeli care pot cauza comportamente nedefinite sau sunt periculoase. Acest analizator promite o rată mică a fals pozitivelor.

Am utilizat \textit{cppcheck} pentru a analiza toate cele cinci aplicații C++ din suită fără a fi nevoie de configurări suplimentare. Procesul de detectare al potențialelor probleme este în totalitate automat, însă pentru stabilirea sigură a existenței unui defect și reproducerea acestuia este nevoie de intervenția manuală a unui expert.

Utilitarul a reușit să identifice cu succes două dintre defectele prezente în aplicații, acestea fiind foarte comune conform \acrfull{cwe}. În fragmentul \ref{defecte_cppcheck}, putem observa mesajele care semnalează dereferențierea unui pointer nul și dubla dealocare de memorie. 

\begin{lstlisting}[caption={Cele două defecte detectate de \textit{cppcheck}}, label={defecte_cppcheck}]
windwow/Window.cpp:120:33: warning: Possible null pointer dereference: p [nullPointer]
flowerpower/src/SmartPotEndpoint.cpp:436:24: error: Memory pointed to by 'target_p' is freed twice. [doubleFree]
\end{lstlisting}

Din păcate, \textit{cppcheck} nu reușește să proceseze întodeauna corect semanticile mai complicate, în fragmentul \ref{fals_pozitive_cppcheck} avem un exemplu de semnal fals pozitiv. Variabila $setResponse$ este inițializată pe ambele ramuri ale unei structuri $if - else$ care urmează după declararea acesteia, însă \textit{cppcheck} nu interpretează corect acest construct.

\begin{lstlisting}[caption={Exemplu de fals pozitiv detectat de \textit{cppcheck}}, label={fals_pozitive_cppcheck}]
windwow/WindowEndpoint.cpp:257:21: note: Uninitialized variable: setResponse
\end{lstlisting}

Observăm ca \textit{cppcheck} este potrivit doar pentru analizarea unor greșeli comune și relativ simple de programare, acesta fiind exclusiv pentru limbajele C și C++. Analizatorul nu poate fi utilizat pentru testarea interacțiunilor dintre aplicații și nici pentru descoperirea de defecte cauzate de tranziții de stare complexe. Deși este rapid și nu necesită configurări, aria de aplicabilitate a acestei unelte rămâne destul de restrânsă.

\subsection{weggli}

\textit{weggli} \footnote{Codul sursă al aplicației poate fi găsit la \url{https://github.com/googleprojectzero/weggli}.} este un utilitar pentru căutări cu înțelegere semantică în interiorul codului sursă al programelor C și C++. Deși nu necesită configurări suplimentare, acest utilitar nu vine cu o serie de reguli de analiză standard, această sarcină rămânând în grija expertului care îl folosește.

Sintaxa folosită pentru efectuarea de căutări este similară cu cea a aplicației \textit{grep} \footnote{Utilitar foarte popular pe sistemele \textit{*nix} pentru a căuta în interiorul documentelor text folosind expresii regulate (\textit{regex}).} însă permite și utilizarea de variabile sau constructe sintactice complicate, nu doar căutări \textit{regex}.

În fragmentul \ref{weggli_nullptr} este o expresie ce va semnala toate zonele de cod sursă unde se inițializează un pointer de tip arbitrar cu valoarea nulă, iar apoi acesta este accesat fără a fi inițializat cu o valoare nenulă. \textit{var} ține locul oricărui identificator și poate fi menționat în continuare, iar caracterul \textit{underscore} poate înlocui orice expresie, observăm astfel cât de ușor putem identifica structuri semantice complexe.

\begin{lstlisting}[label={weggli_nullptr}, caption={Interogare weggli pentru a găsi accesări de pointer nul}]
weggli --cpp '{
    _* $var = nullptr;
    $var[_];
}' ./apps/
\end{lstlisting}

Un alt exemplu poate fi observat în \ref{weggli_json}, unde am dorit să găsim toate accesările de chei \acrshort{json} fără verificare corespunzătoare.

\begin{lstlisting}[label={weggli_json}, caption={Interogare weggli pentru a găsi accesarea de chei JSON fără verificare}]
weggli --cpp '{ 
    Document $document;
    NOT: $document.HasMember(_);
    $document[_]._();
}' ./apps/
\end{lstlisting}

\textit{weggli} poate detecta majoritatea defectelor prezente în suită care sunt legate de un construct de cod C++. Dezavantajele acestei abordări sunt însă reprezentate de faptul că este nevoie de interacțiune umană pentru a formula interogările, majoritatea putând rezulta în niciun defect găsit, dar și faptul că nu se pot detecta defecte de integrare sau logică mai complexă.

\subsection{cwe\_checker} 

\textit{cwe\_checker} \footnote{Codul sursă al aplicației \textit{cwe\_checker} poate fi găsit la \url{https://github.com/fkie-cad/cwe_checker}.}

TODO: tre sa compilez aplicatiile si sa rulez asta, dar ma mai gandesc, poate il scot de tot ca s-ar putea sa fie suficient ce am deja

\section{Analiză cu modelare formală}

TODO: asta e cam complicată, o s-o las la urmă, poate reușesc ca demonstrez măcar un bug așa

% TODO: de gasit un paper despre analiza formala si modelare
% TODO: de reprodus macar un bug folosind modelarea formala si un solver gen Z3 sau un theorem prover